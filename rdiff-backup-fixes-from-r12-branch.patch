diff -urN rdiff-backup-0.12.3.org/CHANGELOG rdiff-backup-0.12.3/CHANGELOG
--- rdiff-backup-0.12.3.org/CHANGELOG	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/CHANGELOG	2003-08-29 21:35:49.000000000 +0200
@@ -1,3 +1,22 @@
+New in v0.12.4 (??????????)
+---------------------------
+
+Specified socket type as SOCK_STREAM.  (Error reported by Erik
+Forsberg.)
+
+Fixed bug backing up unreadable regular files and directories when
+rdiff-backup is run by root on the source site and non-root on the
+destination side.  (Reported by Troels Arvin and Arkadiusz
+Miskiewicz.)
+
+If there is data missing from the destination dir (for instance if a
+user mistakenly deletes it), only warn when restoring, instead of
+exiting with error.
+
+Fixed problems with --restrict options that would cause proper
+sessions to fail.  Thanks to Randall Nortman for error report.
+
+
 New in v0.12.3 (2003/08/08)
 ---------------------------
 
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/backup.py rdiff-backup-0.12.3/rdiff_backup/backup.py
--- rdiff-backup-0.12.3.org/rdiff_backup/backup.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/backup.py	2003-08-29 21:36:00.000000000 +0200
@@ -143,7 +143,7 @@
 		dest_iter = cls.get_dest_select(baserp, for_increment)
 		collated = rorpiter.Collate2Iters(source_iter, dest_iter)
 		cls.CCPP = CacheCollatedPostProcess(
-			collated, Globals.pipeline_max_length*4)
+			collated, Globals.pipeline_max_length*4, baserp)
 		# pipeline len adds some leeway over just*3 (to and from and back)
 		
 	def get_sigs(cls, dest_base_rpath):
@@ -181,15 +181,26 @@
 		elif dest_rorp:
 			dest_sig = dest_rorp.getRORPath()
 			if dest_rorp.isreg():
-				dest_rp = dest_base_rpath.new_index(index)
-				if not dest_rp.isreg():
-					log.ErrorLog.write_if_open("UpdateError", dest_rp,
-						"File changed from regular file before signature")
-					return None
-				dest_sig.setfile(Rdiff.get_signature(dest_rp))
+				sig_fp = cls.get_one_sig_fp(dest_base_rpath.new_index(index))
+				if sig_fp is None: return None
+				dest_sig.setfile(sig_fp)
 		else: dest_sig = rpath.RORPath(index)
 		return dest_sig			
 
+	def get_one_sig_fp(cls, dest_rp):
+		"""Return a signature fp of given index, corresponding to reg file"""
+		if not dest_rp.isreg():
+			log.ErrorLog.write_if_open("UpdateError", dest_rp,
+				"File changed from regular file before signature")
+			return None
+		if Globals.process_uid != 0 and not dest_rp.readable():
+			# This branch can happen with root source and non-root
+			# destination.  Permissions are changed permanently, which
+			# should propogate to the diffs
+			assert dest_rp.isowner(), 'no ownership of %s' % (dest_rp.path,)
+			dest_rp.chmod(0400 | dest_rp.getperms())
+		return Rdiff.get_signature(dest_rp)
+				
 	def patch(cls, dest_rpath, source_diffiter, start_index = ()):
 		"""Patch dest_rpath with an rorpiter of diffs"""
 		ITR = rorpiter.IterTreeReducer(PatchITRB, [dest_rpath, cls.CCPP])
@@ -215,7 +226,7 @@
 
 
 class CacheCollatedPostProcess:
-	"""Cache a collated iter of (source_rorp, dest_rp) pairs
+	"""Cache a collated iter of (source_rorp, dest_rorp) pairs
 
 	This is necessary for two reasons:
 
@@ -237,10 +248,12 @@
 	metadata for it.
 
 	"""
-	def __init__(self, collated_iter, cache_size):
+	def __init__(self, collated_iter, cache_size, dest_root_rp):
 		"""Initialize new CCWP."""
 		self.iter = collated_iter # generates (source_rorp, dest_rorp) pairs
 		self.cache_size = cache_size
+		self.dest_root_rp = dest_root_rp
+
 		self.statfileobj = statistics.init_statfileobj()
 		if Globals.file_statistics: statistics.FileStats.init()
 		metadata.OpenMetadata()
@@ -283,6 +296,10 @@
 		"""
 		if source_rorp: Hardlink.add_rorp(source_rorp, source = 1)
 		if dest_rorp: Hardlink.add_rorp(dest_rorp, source = 0)
+		if (dest_rorp and dest_rorp.isdir() and Globals.process_uid != 0 and
+			dest_rorp.getperms() % 01000 < 0700):
+			dest_rp = self.dest_root_rp.new_index(dest_rorp.index)
+			dest_rp.chmod(0700 | dest_rorp.getperms())
 
 	def shorten_cache(self):
 		"""Remove one element from cache, possibly adding it to metadata"""
@@ -321,6 +338,13 @@
 		if Globals.file_statistics:
 			statistics.FileStats.update(source_rorp, dest_rorp, changed, inc)
 
+		# Update permissions of unreadable directory
+		if (source_rorp and source_rorp.isdir() and Globals.process_uid != 0
+			and success and source_rorp.getperms() % 01000 < 0700):
+			dest_rp = self.dest_root_rp.new_index(source_rorp.index)
+			assert dest_rp.isdir(), dest_rp
+			dest_rp.chmod(source_rorp.getperms())
+
 	def in_cache(self, index):
 		"""Return true if given index is cached"""
 		return self.cache_dict.has_key(index)
@@ -569,3 +593,4 @@
 				self.CCPP.set_inc(index, inc)
 				self.CCPP.flag_success(index)
 
+
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/increment.py rdiff-backup-0.12.3/rdiff_backup/increment.py
--- rdiff-backup-0.12.3.org/rdiff_backup/increment.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/increment.py	2003-08-29 21:36:00.000000000 +0200
@@ -79,7 +79,13 @@
 	if compress: diff = get_inc(incpref, "diff.gz")
 	else:  diff = get_inc(incpref, "diff")
 
-	Rdiff.write_delta(new, mirror, diff, compress)
+	if Globals.process_uid != 0 and not new.readable():
+		# Check for unreadable files
+		old_new_perms = new.getperms()
+		new.chmod(0400 | old_new_perms)
+		Rdiff.write_delta(new, mirror, diff, compress)
+		new.chmod(old_new_perms)
+	else: Rdiff.write_delta(new, mirror, diff, compress)
 	rpath.copy_attribs(mirror, diff)
 	return diff
 
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/Main.py rdiff-backup-0.12.3/rdiff_backup/Main.py
--- rdiff-backup-0.12.3.org/rdiff_backup/Main.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/Main.py	2003-08-29 21:36:00.000000000 +0200
@@ -419,7 +419,8 @@
 def restore_start_log(rpin, target, time):
 	"""Open restore log file, log initial message"""
 	try: Log.open_logfile(datadir.append("restore.log"))
-	except LoggerError, e: Log("Warning, " + str(e), 2)
+	except (LoggerError, Security.Violation), e:
+		Log("Warning - Unable to open " + str(e), 2)
 
 	# Log following message at file verbosity 3, but term verbosity 4
 	log_message = ("Starting restore of %s to %s as it was as of %s." %
@@ -475,11 +476,15 @@
 	global datadir
 	if rpin.isincfile(): relpath = rpin.getincbase().path
 	else: relpath = rpin.path
-	pathcomps = os.path.join(rpin.conn.os.getcwd(), relpath).split("/")
-	assert len(pathcomps) >= 2 # path should be relative to /
+	if rpin.conn is not Globals.local_connection:
+		# For security checking consistency, don't get absolute path
+		pathcomps = relpath.split('/')
+	else: pathcomps = os.path.join(os.getcwd(), relpath).split("/")
+	if not pathcomps[0]: min_len_pathcomps = 2 # treat abs paths differently
+	else: min_len_pathcomps = 1
 
 	i = len(pathcomps)
-	while i >= 2:
+	while i >= min_len_pathcomps:
 		parent_dir = rpath.RPath(rpin.conn, "/".join(pathcomps[:i]))
 		if (parent_dir.isdir() and
 			"rdiff-backup-data" in parent_dir.listdir()): break
@@ -527,7 +532,7 @@
 
 def RemoveOlderThan(rootrp):
 	"""Remove all increment files older than a certain time"""
-	rom_check_dir(rootrp)
+	rot_check_dir(rootrp)
 	try: time = Time.genstrtotime(remove_older_than_string)
 	except Time.TimeException, exc: Log.FatalError(str(exc))
 	timep = Time.timetopretty(time)
@@ -552,13 +557,13 @@
 	else: Log("Deleting increments at times:\n" + inc_pretty_time, 3)
 	manage.delete_earlier_than(Globals.rbdir, time)
 
-def rom_check_dir(rootrp):
+def rot_check_dir(rootrp):
 	"""Check destination dir before RemoveOlderThan"""
 	SetConnections.UpdateGlobal('rbdir',
 								rootrp.append_path("rdiff-backup-data"))
 	if not Globals.rbdir.isdir():
 		Log.FatalError("Unable to open rdiff-backup-data dir %s" %
-					   (datadir.path,))
+					   (Globals.rbdir.path,))
 	checkdest_if_necessary(rootrp)
 
 
@@ -613,6 +618,12 @@
 exists, but we cannot find a valid current_mirror marker.  You can
 avoid this message by removing this directory; however any data in it
 will be lost.
+
+Probably this error was caused because the first rdiff-backup session
+into a new directory failed.  If this is the case it is safe to delete
+the rdiff_backup_data directory because there is no important
+information in it.
+
 """ % (Globals.rbdir.path,))
 	elif len(curmir_incs) == 1: return 0
 	else:
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/regress.py rdiff-backup-0.12.3/rdiff_backup/regress.py
--- rdiff-backup-0.12.3.org/rdiff_backup/regress.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/regress.py	2003-08-29 21:36:00.000000000 +0200
@@ -27,9 +27,9 @@
 increments.  For regular files we examine the mirror file and use the
 increment file to get the old data if the mirror file is out of date.
 
-Currently this does recover hard links.  This make make the regressed
-directory take up more disk space, but hard links can still be
-recovered.
+Currently this does not recover hard links.  This may make the
+regressed directory take up more disk space, but hard links can still
+be recovered.
 
 """
 
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/restore.py rdiff-backup-0.12.3/rdiff_backup/restore.py
--- rdiff-backup-0.12.3.org/rdiff_backup/restore.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/restore.py	2003-08-29 21:36:00.000000000 +0200
@@ -287,28 +287,43 @@
 		return "\n".join((s1, s2, s3))
 
 	def get_rf(self, index):
-		"""Return RestoreFile of given index"""
+		"""Return RestoreFile of given index, or None"""
 		while 1:
-			if not self.rf_list: self.add_rfs(index)
+			if not self.rf_list:
+				if not self.add_rfs(index): return None
 			rf = self.rf_list.pop(0)
 			if rf.index < index: continue
 			elif rf.index == index: return rf
 			self.rf_list.insert(0, rf)
-			self.add_rfs(index)
+			if not self.add_rfs(index): return None
 
 	def get_fp(self, index):
 		"""Return the file object (for reading) of given index"""
+		rf = self.get_rf(index)
+		if not rf:
+			log.Log("""Error: Unable to retrieve data for file %s!
+The cause is probably data loss from the destination directory.""" %
+					(index and "/".join(index) or '.',), 2)
+			return cStringIO.StringIO('')
 		return self.get_rf(index).get_restore_fp()
 
 	def add_rfs(self, index):
-		"""Given index, add the rfs in that same directory"""
+		"""Given index, add the rfs in that same directory
+
+		Returns false if no rfs are available, which usually indicates
+		an error.
+
+		"""
 		if not index: return self.root_rf
 		parent_index = index[:-1]
 		temp_rf = RestoreFile(self.root_rf.mirror_rp.new_index(parent_index),
 							  self.root_rf.inc_rp.new_index(parent_index), [])
 		new_rfs = list(temp_rf.yield_sub_rfs())
-		assert new_rfs, "No RFs added for index %s" % index
+		if not new_rfs:
+			log.Log("Warning: No RFs added for index %s" % (index,), 2)
+			return 0
 		self.rf_list[0:0] = new_rfs
+		return 1
 
 
 class RestoreFile:
@@ -432,7 +447,13 @@
 
 	def yield_sub_rfs(self):
 		"""Return RestoreFiles under current RestoreFile (which is dir)"""
-		assert self.mirror_rp.isdir() or self.inc_rp.isdir()
+		if not self.mirror_rp.isdir() and not self.inc_rp.isdir():
+			log.Log("""Warning: directory %s seems to be missing from backup!
+
+This is probably due to files being deleted manually from the
+rdiff-backup destination directory.  In general you shouldn't do this,
+as data loss may result.\n""" % (self.mirror_rp.get_indexpath(),), 2)
+			return
 		if self.mirror_rp.isdir():
 			mirror_iter = self.yield_mirrorrps(self.mirror_rp)
 		else: mirror_iter = iter([])
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/rpath.py rdiff-backup-0.12.3/rdiff_backup/rpath.py
--- rdiff-backup-0.12.3.org/rdiff_backup/rpath.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/rpath.py	2003-08-29 21:36:00.000000000 +0200
@@ -216,7 +216,7 @@
 
 	"""
 	assert rpath.conn is Globals.local_connection
-	s = socket.socket(socket.AF_UNIX)
+	s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
 	try: s.bind(rpath.path)
 	except socket.error, exc:
 		raise SkipFileException("Socket error: " + str(exc))
@@ -828,6 +828,14 @@
 			raise RPathException("Error closing file")
 		self.setdata()
 
+	def write_string(self, s, compress = None):
+		"""Write string s into rpath"""
+		assert not self.lstat(), "File %s already exists" % (self.path,)
+		outfp = self.open("wb", compress = compress)
+		outfp.write(s)
+		assert not outfp.close()
+		self.setdata()
+
 	def isincfile(self):
 		"""Return true if path looks like an increment file
 
diff -urN rdiff-backup-0.12.3.org/rdiff_backup/Security.py rdiff-backup-0.12.3/rdiff_backup/Security.py
--- rdiff-backup-0.12.3.org/rdiff_backup/Security.py	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/rdiff_backup/Security.py	2003-08-29 21:36:00.000000000 +0200
@@ -116,7 +116,9 @@
 						"Log.log_to_file",
 						"SetConnections.add_redirected_conn",
 						"RedirectedRun",
-						"sys.stdout.write"]
+						"sys.stdout.write",
+						"robust.install_signal_handlers",
+						"Hardlink.initialize_dictionaries"]
 	if sec_level == "minimal": pass
 	elif sec_level == "read-only" or sec_level == "update-only":
 		allowed_requests.extend(
@@ -125,23 +127,28 @@
 			 "os.getuid",
 			 "os.listdir",
 			 "Time.setcurtime_local",
-			 "robust.Resume.ResumeCheck",
-			 "backup.SourceStruct.split_initial_dsiter",
-			 "backup.SourceStruct.get_diffs_and_finalize",
 			 "rpath.gzip_open_local_read",
 			 "rpath.open_local_read"])
+		if sec_level == "read-only":
+			allowed_requests.extend(
+				["restore.MirrorStruct.set_mirror_and_rest_times",
+				 "restore.MirrorStruct.initialize_rf_cache",
+				 "restore.MirrorStruct.get_diffs",
+				 "backup.SourceStruct.set_source_select",
+				 "backup.SourceStruct.get_source_select",
+				 "backup.SourceStruct.get_diffs"])
 		if sec_level == "update-only":
 			allowed_requests.extend(
-				["Log.open_logfile_local", "Log.close_logfile_local",
-				 "Log.close_logfile_allconn", "Log.log_to_file",
-				 "log.Log.log_to_file",
+				["log.Log.open_logfile_local", "log.Log.close_logfile_local",
+				 "log.ErrorLog.open", "log.ErrorLog.isopen",
+				 "log.ErrorLog.close",
 				 "robust.SaveState.init_filenames",
 				 "robust.SaveState.touch_last_file",
-				 "backup.DestinationStruct.get_sigs",
-				 "backup.DestinationStruct.patch_w_datadir_writes",
-				 "backup.DestinationStruct.patch_and_finalize",
-				 "backup.DestinationStruct.patch_increment_and_finalize",
+				 "backup.DestinationStruct.set_rorp_cache",
+				 "backup.DestinationStruct.get_sigs",				 
+				 "backup.DestinationStruct.patch_and_increment",
 				 "Main.backup_touch_curmirror_local",
+				 "Main.backup_remove_curmirror_local",
 				 "Globals.ITRB.increment_stat",
 				 "statistics.record_error",
 				 "log.ErrorLog.write_if_open"])
diff -urN rdiff-backup-0.12.3.org/README rdiff-backup-0.12.3/README
--- rdiff-backup-0.12.3.org/README	2003-08-29 21:34:54.000000000 +0200
+++ rdiff-backup-0.12.3/README	2003-08-29 21:35:49.000000000 +0200
@@ -14,15 +14,24 @@
 
 	python setup.py install --prefix=/usr/local
 
-A few special build arguments can be specified such as --librsync-dir,
---lflags, and --libs, and the LIBRSYNC_DIR, LFLAGS, and LIBS
-environment variables will also be used.  Running setup.py with no
-arguments will also display some help.
+The setup script expects to find librsync headers and libraries in the
+default location, usually /usr/include and /usr/lib.  If you want the
+setup script to check different locations, use the --librsync-dir
+switch or the LIBRSYNC_DIR environment variable.  For instance,
+
+	python setup.py --librsync-dir=/usr/local build
+
+instructs the setup program to look in /usr/local/include and
+/usr/local/lib for the librsync files.
+
+Finally, the --lflags and --libs options, and the LFLAGS and LIBS
+environment variables are also recognized.  Running setup.py with no
+arguments will display some help.
 
 
 REQUIREMENTS:
 
-Remember that you must have Python 2.2 or later and librsync 0.9.5.1
+Remember that you must have Python 2.2 or later and librsync 0.9.6
 or later installed.  For Python, see http://www.python.org.  The
 rdiff-backup homepage at http://rdiff-backup.stanford.edu/ should have
 a recent version of librsync; otherwise see the librsync homepage at
